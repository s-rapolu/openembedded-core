--- a/svr-main.c	2016-07-21 20:47:09.000000000 +0530
+++ b/svr-main.c	2019-09-30 17:58:24.112156044 +0530
@@ -30,19 +30,45 @@
 #include "runopts.h"
 #include "dbrandom.h"
 #include "crypto_desc.h"
+#include <pthread.h>
+#include "libdropbear.h"
+#include "linkedlist.h"
 
 static size_t listensockets(int *sock, size_t sockcount, int *maxfd);
 static void sigchld_handler(int dummy);
 static void sigsegv_handler(int);
 static void sigintterm_handler(int fish);
+void init_dropbear(int argc, char ** argv);
+void free_client_info();
+static int setargs(char *args, char **argv);
+char **parsedargs(char *args, int *argc);
+void freeparsedargs(char **argv);
+
+
+
+struct list_head client_connections_info;
+
+struct active_clients{
+	struct client_info info;
+	struct list_head client_list;
+};
+
+static int pluginActivated = 0;
+static pthread_t threadID;
+int served_clients = 0;
+int server_active = 0;
+int client_info_available = 0;
+pthread_mutex_t lock;
+
 #ifdef INETD_MODE
 static void main_inetd(void);
 #endif
 #ifdef NON_INETD_MODE
-static void main_noinetd(void);
+static void* main_noinetd(void *);
 #endif
 static void commonsetup(void);
 
+#if 0
 #if defined(DBMULTI_dropbear) || !defined(DROPBEAR_MULTI)
 #if defined(DBMULTI_dropbear) && defined(DROPBEAR_MULTI)
 int dropbear_main(int argc, char ** argv)
@@ -75,6 +101,214 @@
 	return -1;
 }
 #endif
+#endif
+
+void init_dropbear(int argc, char ** argv)
+{
+	server_active = 1;
+	_dropbear_exit = svr_dropbear_exit;
+	_dropbear_log = svr_dropbear_log;
+	disallow_core();
+	/* get commandline options */
+	svr_getopts(argc, argv);
+	/* Note: commonsetup() must happen before we daemon()ise. Otherwise
+           daemon() will chdir("/"), and we won't be able to find local-dir
+           hostkeys. */
+	commonsetup();
+	INIT_LIST_HEAD(&client_connections_info);
+	client_info_available = 1;
+}
+ 
+
+static int setargs(char *args, char **argv)
+{
+	int count = 0;
+	while (isspace(*args)) ++args;
+	while (*args) {
+		if (argv) argv[count] = args;
+		while (*args && !isspace(*args)) ++args;
+		if (argv && *args) *args++ = '\0';
+		while (isspace(*args)) ++args;
+		count++;
+	}
+	return count;
+}
+
+char **parsedargs(char *args, int *argc)
+{
+	char **argv = NULL;
+	int    argn = 0;
+
+	if (args && *args
+			&& (args = strdup(args))
+			&& (argn = setargs(args,NULL))
+			&& (argv = malloc((argn+1) * sizeof(char *)))) {
+		*argv++ = args;
+		argn = setargs(args,argv);
+	}
+
+	if (args && !argv) free(args);
+	*argc = argn;
+	return argv;
+}
+
+void freeparsedargs(char **argv)
+{
+	if (argv) {
+		free(argv[-1]);
+		free(argv-1);
+	}
+}
+
+
+void activate_dropbear(char* string)
+{
+	int status;
+	int argc;
+	char **argv;
+	char str[100];
+
+	if(pluginActivated == 1)
+	{
+		printf("Plugin already Activated \n");
+		return;
+	}
+	printf("recieved input=%s\n", string);
+	memset(str, '\0', sizeof(str));
+	strncpy(str, "dropbear ", strlen("dropbear "));
+	strncpy(str+strlen("dropbear "), string, strlen(string));
+	printf("str = %s\n", str);
+	
+	argv = parsedargs(str,&argc);
+	printf("Argument count (argc) = %d\n",argc);
+	for (int i = 0; i < argc; i++)
+		printf("argv[%d] = %s\n", i, argv[i]);
+
+	init_dropbear(argc, argv);
+	if (pthread_mutex_init(&lock, NULL) != 0)
+	{
+		printf("\n mutex init has failed\n");
+		return;
+	}
+	status = pthread_create(&threadID,NULL,main_noinetd,NULL);
+	if(status != 0)
+	{
+		printf("Error in creating thread\n");
+		return;
+	}
+	freeparsedargs(argv);
+	printf("Plugin Activated \n");
+	pluginActivated =1;
+}
+
+void deactivate_dropbear()
+{
+	if(pluginActivated == 1)
+	{
+		server_active = 0;
+		pthread_join(threadID, 0);
+		pluginActivated = 0;
+	}
+	client_info_available = 0;
+	served_clients =0;
+	pthread_mutex_destroy(&lock);
+	printf("Plugin DeActivated \n");
+	return;
+}
+
+/*Return the number of clients currently connected*/
+
+int get_active_sessions_count(){
+	int count=0;
+	if(client_info_available){
+		struct active_clients *client;
+		struct list_head *ptr_list;
+		list_for_each(ptr_list,&client_connections_info){
+			client = list_entry(ptr_list,struct active_clients,client_list);
+			if(client){
+				count++;
+			}
+		}
+	}
+	return count;
+}
+
+/*To get the list of connections that are currently serving*/
+void  get_active_sessions_info(struct client_info* connected_clients,int connections_count){
+	if(client_info_available){
+		int count = 0;
+		struct active_clients *client;
+		struct list_head *ptr_list;
+		list_for_each(ptr_list,&client_connections_info){
+			client = list_entry(ptr_list, struct active_clients, client_list );
+			if(client && (count < connections_count)){
+				connected_clients[count].pid=client->info.pid;
+				strcpy(connected_clients[count].ipaddress,client->info.ipaddress);
+				strcpy(connected_clients[count].timestamp,client->info.timestamp);
+				count++;
+			}
+			else{
+				break;
+			}
+		}
+	}	
+}
+
+/* To terminate  the server connection to client with the pid  */
+int  close_client_session(int client_pid){
+	int pid_existing=0;
+	struct active_clients *client;
+	struct list_head *ptr_list;
+	if(client_info_available){
+		list_for_each(ptr_list,&client_connections_info){
+			client = list_entry(ptr_list,struct active_clients,client_list);
+			if(client && (client->info.pid == client_pid)){
+				pid_existing=1;
+				break;
+			}
+		}
+		if(pid_existing){
+			if(kill(client_pid,SIGKILL)== -1){
+				printf("Error during close session: %s\n", strerror(errno));
+				return errno;
+			}
+			else{
+				return 0;
+			}
+		}
+		else{
+			return -1;
+		}
+	}
+	else{
+		return -1;
+	}
+}
+
+/* total number of connections are srved till now*/
+int get_total_sessions_served(){
+	return served_clients;
+}
+
+void free_client_info(){
+	if(client_info_available){
+		struct active_clients *client;
+		struct list_head *ptr_list;
+		list_for_each(ptr_list, &client_connections_info){
+			client = list_entry(ptr_list,struct active_clients, client_list);
+			if (client){
+				if(close_client_session(client->info.pid) != 0 ){
+					printf("unable to kill the process : %d\n",client->info.pid);
+				}
+			}
+			else{
+				break;
+			}
+		}
+	}
+
+}
+
 
 #ifdef INETD_MODE
 static void main_inetd() {
@@ -104,25 +338,21 @@
 #endif /* INETD_MODE */
 
 #ifdef NON_INETD_MODE
-static void main_noinetd() {
+static void* main_noinetd(void *UNUSED(unused)){
 	fd_set fds;
 	unsigned int i, j;
 	int val;
 	int maxsock = -1;
 	int listensocks[MAX_LISTEN_ADDR];
 	size_t listensockcount = 0;
-	FILE *pidfile = NULL;
+	//FILE *pidfile = NULL;
 
 	int childpipes[MAX_UNAUTH_CLIENTS];
 	char * preauth_addrs[MAX_UNAUTH_CLIENTS];
 
 	int childsock;
 	int childpipe[2];
-
-	/* Note: commonsetup() must happen before we daemon()ise. Otherwise
-	   daemon() will chdir("/"), and we won't be able to find local-dir
-	   hostkeys. */
-	commonsetup();
+	struct timeval timeout;
 
 	/* sockets to identify pre-authenticated clients */
 	for (i = 0; i < MAX_UNAUTH_CLIENTS; i++) {
@@ -141,6 +371,7 @@
 		FD_SET(listensocks[i], &fds);
 	}
 
+#if 0
 	/* fork */
 	if (svr_opts.forkbg) {
 		int closefds = 0;
@@ -154,6 +385,7 @@
 		}
 	}
 
+#endif
 	/* should be done after syslog is working */
 	if (svr_opts.forkbg) {
 		dropbear_log(LOG_INFO, "Running in background");
@@ -161,13 +393,17 @@
 		dropbear_log(LOG_INFO, "Not backgrounding");
 	}
 
+#if 0
 	/* create a PID file so that we can be killed easily */
 	pidfile = fopen(svr_opts.pidfile, "w");
 	if (pidfile) {
 		fprintf(pidfile, "%d\n", getpid());
 		fclose(pidfile);
 	}
+#endif
 
+	timeout.tv_sec = 5;
+	timeout.tv_usec = 0;
 	/* incoming connection select loop */
 	for(;;) {
 
@@ -186,11 +422,18 @@
 			}
 		}
 
-		val = select(maxsock+1, &fds, NULL, NULL, NULL);
+		val = select(maxsock+1, &fds, NULL, NULL, &timeout);
 
-		if (exitflag) {
-			unlink(svr_opts.pidfile);
-			dropbear_exit("Terminated by signal");
+		if (!server_active) {
+			//unlink(svr_opts.pidfile);
+			//dropbear_exit("Terminated by signal");
+			/* make sure we close sockets */
+			FD_ZERO(&fds);
+			for (i = 0; i < listensockcount; i++) {
+				m_close(listensocks[i]);
+			}
+			free_client_info();
+			break;
 		}
 		
 		if (val == 0) {
@@ -281,6 +524,22 @@
 			if (fork_ret > 0) {
 
 				/* parent */
+				/* taking the pids and respective IP address and timestamp to structure list*/
+				time_t now;
+				time(&now);
+				struct active_clients *client;
+				served_clients++;
+				client = (struct active_clients *)malloc(sizeof(struct active_clients));
+				if(!client){
+					printf("unable to create a memory for active clients structure\n ");
+				}
+				client->info.pid = fork_ret;
+				strcpy(client->info.ipaddress, remote_host);
+				strcpy(client->info.timestamp,ctime(&now));
+				client->info.timestamp[strlen(client->info.timestamp) - 1 ] = '\0';
+				pthread_mutex_lock(&lock);
+				list_add_tail(&(client->client_list),&client_connections_info);
+				pthread_mutex_unlock(&lock);
 				childpipes[conn_idx] = childpipe[0];
 				m_close(childpipe[1]);
 				preauth_addrs[conn_idx] = remote_host;
@@ -328,6 +587,7 @@
 	} /* for(;;) loop */
 
 	/* don't reach here */
+	return NULL;
 }
 #endif /* NON_INETD_MODE */
 
@@ -338,10 +598,26 @@
 
 	const int saved_errno = errno;
 
-	while(waitpid(-1, NULL, WNOHANG) > 0) {}
+	int  pid;
+	/* disconnected ports are removing from structure List */
+	while ((pid = waitpid(-1, NULL, WNOHANG)) > 0) {
+		struct active_clients *client;
+		struct list_head *ptr_list;
+
+		list_for_each(ptr_list, &client_connections_info){
+			client  = list_entry(ptr_list,struct active_clients, client_list);
+			if (client && client->info.pid == pid){
+				pthread_mutex_lock(&lock);
+				list_del(ptr_list);
+				pthread_mutex_unlock(&lock);
+				free(client);
+				break;
+			}
+		}
+	}
 
 	sa_chld.sa_handler = sigchld_handler;
-	sa_chld.sa_flags = SA_NOCLDSTOP;
+	sa_chld.sa_flags = SA_NOCLDSTOP | SA_RESTART ;
 	sigemptyset(&sa_chld.sa_mask);
 	if (sigaction(SIGCHLD, &sa_chld, NULL) < 0) {
 		dropbear_exit("signal() error");
